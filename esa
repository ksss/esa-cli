#!/usr/bin/env ruby
# Author: ksss <co000ri@gmail.com>
# License: MIT

require 'io/console'
require 'optparse'
require 'esa'

class String
  def to_bold
    "\e[1m#{self}\e[m"
  end
end

class CLI
  Page = Struct.new(:page, :per_page)

  attr_reader :client

  def initialize(client)
    @client = client
  end

  HELP_LINE = "j:down, k:up, l: next, h: back, Enter:show, q: quit"

  def run(argv)
    public_send(*argv)
  end

  def api(*args)
    puts @client.public_send(*args).body.to_json
  end

  ViewOption = Struct.new(
    :page,
    :per_page,
  )
  def view(*args)
    vo = ViewOption.new(
      1,
      20,
    )
    OptionParser.new do |opt|
      opt.on('--page NUM', 'page number (default 1)', Integer) do |arg|
        vo.page = arg
      end
      opt.on('--per-page NUM', 'page size (default 20)', Integer) do |arg|
        vo.per_page = arg
      end
    end.parse!(args)
    @client.current_team = args.shift if args.empty?.!
    cache = []

    posts = lines = off = nil
    refresh = lambda do
      cache[vo.page] = fetch_posts(vo) if cache[vo.page].nil?
      posts = cache[vo.page]
      max_screen_name_len = posts.map { |post| post["created_by"]["screen_name"].length }.max
      lines = posts.map do |post|
        sprintf("%#{max_screen_name_len}s: %s", post["created_by"]["screen_name"], post["name"])
      end
      off = 0
    end
    decorate = lambda do |md|
      md.each_line.map do |line|
        if /^#/ =~ line
          line.to_bold
        else
          line
        end
      end.join("\n")
    end
    refresh.call
    while true
      print "\e[0J".freeze
      buf = "#{HELP_LINE.to_bold}\n"
      lines.each_with_index do |line, i|
        buf << if off == i
                 "\e[30;47m#{line}\e[0m\n"
               else
                 "#{line}\n"
               end
      end
      buf << "\e[#{lines.length + 1}A"
      print buf

      ch = $stdin.getch.ord
      case ch
      when 0x6a # j
        off += 1 if off+1 < lines.length
      when 0x6b # k
        off -= 1 if 0 < off
      when 0x6c # l
        vo.page += 1
        refresh.call
      when 0x68 # h
        vo.page -= 1 if 0 < vo.page
        refresh.call
      when 0x0d # Enter
        post = posts[off]
        IO.popen("less -R", "w") do |io|
          io.puts post["url"]
          io.puts post["full_name"].to_bold
          io.puts
          io.puts decorate.call(post["body_md"])
        end
      when 0x71 # q
        return
      end
    end
  end

  private

  def fetch_posts(opts = {})
    res = client.posts(opts.to_h)
    unless res.status == 200
      raise "#{res.status} #{res.body['message']}"
    end
    res.body["posts"]
  end
end

client = Esa::Client.new(
  access_token: ENV["ESA_ACCESS_TOKEN"],
  current_team: ENV["ESA_CURRENT_TEAM"],
)
CLI.new(client).run(ARGV)
