#!/usr/bin/env ruby
# Author: ksss <co000ri@gmail.com>
# License: MIT
# Env:
#   ESA_ACCESS_TOKEN: Your esa access token
#   ESA_CURRENT_TEAM: Your esa team name (default docs)
# Key:
#       j: Down
#       k: Up
#       l: Next page
#       h: Back page
#   Enter: Show a post body
#       q: Quit

require 'io/console'
require 'esa'

class CLI
  Page = Struct.new(:page, :per_page)

  attr_reader :client

  def initialize(client)
    @client = client
  end

  def posts(opts = {})
    res = client.posts(opts.to_h)
    unless res.status == 200
      raise "#{res.status} #{res.body['message']}"
    end
    res.body["posts"]
  end

  HELP_LINE = "j:down, k:up, l: next, h: back, Enter:show, q: quit"

  def run(argv)
    page = Page.new(1, 30)
    posts = lines = off = nil
    refresh = lambda do
      posts = posts(page)
      lines = posts.map do |post|
        sprintf("%6s: %s", post["number"], post["name"])
      end
      off = 0
    end
    refresh.call
    while true
      print "\e[0J".freeze
      buf = "\e[1m#{HELP_LINE}\e[m\n"
      lines.each_with_index do |line, i|
        buf << if off == i
                 "\e[30;47m#{line}\e[0m\n"
               else
                 "#{line}\n"
               end
      end
      buf << "\e[#{lines.length + 1}A"
      print buf

      ch = $stdin.getch.ord
      case ch
      when 0x6a # j
        off += 1 if off+1 < lines.length
      when 0x6b # k
        off -= 1 if 0 < off
      when 0x6c # l
        page.page += 1
        refresh.call
      when 0x68 # h
        page.page -= 1 if 0 < page.page
        refresh.call
      when 0x0d # Enter
        post = posts[off]
        IO.popen("less -R", "w") do |io|
          io.puts post["url"]
          io.puts "\e[1m#{post["full_name"]}\e[m"
          io.puts
          io.puts post["body_md"]
        end
      when 0x71 # q
        return
      end
    end
  end
end

client = Esa::Client.new(
  access_token: ENV["ESA_ACCESS_TOKEN"],
  current_team: ENV["ESA_CURRENT_TEAM"] || "docs"
)
CLI.new(client).run(ARGV)
